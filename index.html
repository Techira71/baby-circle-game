<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Baby Circle">
    <title>Baby Gray Circle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

```
    body, html {
        height: 100vh;
        width: 100vw;
        background-color: #000;
        overflow: hidden;
        font-family: Arial, sans-serif;
        position: fixed;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
    }
    
    #gameContainer {
        width: 100vw;
        height: 100vh;
        position: relative;
        background-color: #000;
        cursor: pointer;
    }
    
    .circle {
        width: 120px;
        height: 120px;
        border: 6px solid #888888;
        background-color: #888888;
        border-radius: 50%;
        position: absolute;
        transition: transform 0.2s ease-out;
        box-shadow: 0 0 20px rgba(136, 136, 136, 0.5);
        transform-origin: center;
        z-index: 10;
    }
    
    .touched {
        transform: scale(1.2);
        animation: pulse 0.4s ease-in-out;
    }
    
    @keyframes pulse {
        0% { transform: scale(1.2); }
        50% { transform: scale(1.3); }
        100% { transform: scale(1.2); }
    }
    
    .sparkle {
        position: absolute;
        width: 6px;
        height: 6px;
        background-color: #888888;
        border-radius: 50%;
        pointer-events: none;
        animation: sparkleAnimation 1.2s ease-out forwards;
        z-index: 20;
    }
    
    @keyframes sparkleAnimation {
        0% {
            opacity: 1;
            transform: scale(1);
        }
        100% {
            opacity: 0;
            transform: scale(3) translate(var(--dx), var(--dy));
        }
    }
</style>
```

</head>
<body>
    <div id="gameContainer">
        <div id="grayCircle" class="circle"></div>
    </div>

```
<script>
    class BabyGrayCircleGame {
        constructor() {
            this.grayCircle = document.getElementById('grayCircle');
            this.container = document.getElementById('gameContainer');
            this.circleSize = 120;
            this.activeTouches = new Map();
            
            this.circle = {
                element: this.grayCircle,
                x: 0,
                y: 0
            };
            
            this.init();
            this.setupEventListeners();
        }
        
        init() {
            // Start circle in center of screen
            this.centerCircle();
        }
        
        centerCircle() {
            const containerRect = this.container.getBoundingClientRect();
            this.circle.x = (containerRect.width - this.circleSize) / 2;
            this.circle.y = (containerRect.height - this.circleSize) / 2;
            this.updateCirclePosition();
        }
        
        updateCirclePosition() {
            this.circle.element.style.left = this.circle.x + 'px';
            this.circle.element.style.top = this.circle.y + 'px';
        }
        
        setupEventListeners() {
            // Handle multi-touch events
            this.container.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handleTouchStart(e);
            });
            
            this.container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                this.handleTouchMove(e);
            });
            
            this.container.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.handleTouchEnd(e);
            });
            
            // Handle mouse events for desktop testing
            this.container.addEventListener('mousedown', (e) => {
                this.handleSingleTouch(e.clientX, e.clientY, 'mouse');
            });
            
            // Prevent scrolling and zooming
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('gesturestart', (e) => {
                e.preventDefault();
            });
            
            // Handle orientation changes
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    this.centerCircle();
                }, 100);
            });
            
            window.addEventListener('resize', () => {
                this.centerCircle();
            });
        }
        
        handleTouchStart(e) {
            // Process each new touch
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                this.activeTouches.set(touch.identifier, {
                    x: touch.clientX,
                    y: touch.clientY,
                    startTime: Date.now()
                });
                
                // Check if this touch is on the circle
                this.handleSingleTouch(touch.clientX, touch.clientY, touch.identifier);
            }
        }
        
        handleTouchMove(e) {
            // Update active touches positions
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (this.activeTouches.has(touch.identifier)) {
                    const activeTouch = this.activeTouches.get(touch.identifier);
                    activeTouch.x = touch.clientX;
                    activeTouch.y = touch.clientY;
                }
            }
        }
        
        handleTouchEnd(e) {
            // Remove ended touches
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                this.activeTouches.delete(touch.identifier);
            }
        }
        
        handleSingleTouch(clientX, clientY, touchId) {
            const circleRect = this.circle.element.getBoundingClientRect();
            const circleCenterX = circleRect.left + circleRect.width / 2;
            const circleCenterY = circleRect.top + circleRect.height / 2;
            
            // Check if touch is on the circle
            const distance = Math.sqrt(
                Math.pow(clientX - circleCenterX, 2) + 
                Math.pow(clientY - circleCenterY, 2)
            );
            
            if (distance <= this.circleSize / 2) {
                this.touchCircle(circleCenterX, circleCenterY);
            }
        }
        
        touchCircle(centerX, centerY) {
            // Move circle to random new position
            const angle = Math.random() * 2 * Math.PI;
            const moveDistance = Math.random() * 150 + 80; // Random distance between 80-230px
            
            const containerRect = this.container.getBoundingClientRect();
            const maxX = containerRect.width - this.circleSize;
            const maxY = containerRect.height - this.circleSize;
            
            let newX = this.circle.x + Math.cos(angle) * moveDistance;
            let newY = this.circle.y + Math.sin(angle) * moveDistance;
            
            // Keep within bounds
            newX = Math.max(0, Math.min(maxX, newX));
            newY = Math.max(0, Math.min(maxY, newY));
            
            // If too close to edge, try opposite direction
            if (newX <= 50 || newX >= maxX - 50 || newY <= 50 || newY >= maxY - 50) {
                newX = this.circle.x - Math.cos(angle) * moveDistance;
                newY = this.circle.y - Math.sin(angle) * moveDistance;
                newX = Math.max(50, Math.min(maxX - 50, newX));
                newY = Math.max(50, Math.min(maxY - 50, newY));
            }
            
            this.circle.x = newX;
            this.circle.y = newY;
            this.updateCirclePosition();
            
            // Add visual feedback
            this.circle.element.classList.add('touched');
            this.createSparkles(centerX, centerY);
            
            setTimeout(() => {
                this.circle.element.classList.remove('touched');
            }, 400);
        }
        
        createSparkles(centerX, centerY) {
            const sparkleCount = 8;
            
            for (let i = 0; i < sparkleCount; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                
                const angle = (i / sparkleCount) * 2 * Math.PI;
                const distance = Math.random() * 60 + 40; // Random distance
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance;
                
                sparkle.style.left = centerX + 'px';
                sparkle.style.top = centerY + 'px';
                sparkle.style.setProperty('--dx', dx + 'px');
                sparkle.style.setProperty('--dy', dy + 'px');
                
                document.body.appendChild(sparkle);
                
                setTimeout(() => {
                    if (sparkle.parentNode) {
                        sparkle.parentNode.removeChild(sparkle);
                    }
                }, 1200);
            }
        }
    }
    
    // Start the game when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        new BabyGrayCircleGame();
    });
</script>
```

</body>
</html>
